<html>
<head>
	<style>
		#hexagon { border: thin dashed red; }
	</style>
</head>
<body>
<canvas id="hexagon" onmouseenter="animateOut(this)" onmouseout="animateIn(this)"></canvas>
<script>
//
class GridCell {
	constructor(initT) {
		this.s = 0;
		this.pr = 0;
		this.st = 0;
		this.ao = true;
	}
}
function createArray(length) {
	var arr = new Array(length || 0), i = length;
	if(arguments.length > 1) {
		var args = Array.prototype.slice.call(arguments, 1);
		while(i--) arr[length-1 - i] = createArray.apply(this, args);
	}
	else {
		arr.fill(0);
		arr= arr.map(x => new GridCell(x));
	}
	return arr;
}
var size = 20;
var grid = createArray(1,1);
var delay = 20;
//setInterval(repeat, 50);
//setTimeout(repeat, 1000);
function handleSquare(gridcell, ctx) {
	var d = new Date();
	var t = d.getTime();
	
	//grid[0][0].t = t;
	ctx2d = ctx.getContext('2d');
	
	var dt = (t - gridcell.st)/150.;
	//console.log("dt: " + dt.toString());
	dt = Math.min(Math.PI*2., Math.max(0.0, dt));
	
	var zero_one_time_sin = Math.sin(dt);
	var zero_one_time_cos = Math.cos(dt);
	console.log("sine: " + zero_one_time_sin.toString())
	var d_scale = (zero_one_time_sin*0.5);
	console.log("d_scale: " + d_scale.toString())
	var d_rot = Math.atan2(zero_one_time_sin, zero_one_time_cos);
	if(!gridcell.ao) {
		//console.log("Flipping");
		//console.log(dt);
		//var dtp = (t - gridcell.st)/150.;
		//console.log(dtp);
		d_scale = -d_scale;
		//console.log(d_rot);
		d_rot = -d_rot;
		//console.log(d_rot);
	}
	var scale = size*(d_scale + gridcell.s + 1.0);
	console.log("Scale compute: " + scale.toString())
	//console.log("PR: " + gridcell.pr.toString())
	var rot = d_rot + gridcell.pr;
	///console.log("DRot: " + d_rot.toString());
	//console.log("Rot: " + rot.toString());
	if(rot >= 0 && rot <= Math.PI/2.) {
		//not done
		setTimeout(handleSquare, delay, gridcell, ctx);
		gridcell.st = t;
		gridcell.pr += d_rot;
		gridcell.s += d_scale;
	}  else {
		//done - cleanup
		gridcell.st = 0;
		if(gridcell.ao) {
			// end of dilation, max the values
			gridcell.pr = Math.PI/2.;
			gridcell.s = 0.5;
		} else {
			// end of erosion, min the values
			gridcell.pr = 0.;
			gridcell.s = 0.;
		}
	}

	if (rot > Math.PI/2.) {
		// Clip the dilation
		rot = Math.PI/2.;
		
	} else if(rot < 0.0) {
		// Clip the erosion
		rot = 0.;
	}
	if(scale < size)
		scale = size;
	if(scale > 1.5*size)
		scale = 1.5*size;
	console.log("Scale: " + scale.toString());
	rotateSquare(ctx2d, 50, 50, scale, rot-Math.PI/4.);
	
	// console.log("Readout:")
	// console.log(dt);
	//console.log(scale);
	//console.log(rot);
	// console.log(gridcell);
	// console.log(scale);
}

function animateIn(ctx) {
	console.log("Animating in");
	grid[0][0].ao = false;
	console.log("Before: ");
	console.log(grid[0][0]);
	var d = new Date();
	var t = d.getTime();
	
	grid[0][0].st = t-delay;
	
	handleSquare(grid[0][0], ctx);
	console.log("After: ");
	console.log(grid[0][0]);
}

function animateOut(ctx) {
	console.log("Animating out");
	grid[0][0].ao = true;
	if(grid[0][0].st == 0) {
		var d = new Date();
		var t = d.getTime();
		grid[0][0].st = t;
	}
	handleSquare(grid[0][0], ctx);
}

function repeat() {
	var d = new Date();
	var t = d.getTime();
	var ctx = document.getElementById('hexagon').getContext('2d');
	var zero_one_time_sin = Math.sin(t/500);
	var zero_one_time_cos = Math.cos(t/500);
	
	var scale = size*(zero_one_time_sin*0.5+1.0);
	var rot = Math.atan2(zero_one_time_cos, zero_one_time_sin);
	rotateSquare(ctx, 50, 50, scale, rot);
}
function clearcanvas() {
	var c = document.getElementById("hexagon");
	var ctx = c.getContext("2d");
	ctx.fillStyle = "#FFFFFF";
	ctx.fillRect(0, 0, 100, 100);
}

function rotateSquare(ctx, x, y, scale, rot) {
	clearcanvas();	

	// hexagon
	var numberOfSides = 4;

	ctx.beginPath();
	ctx.moveTo (x +  scale * Math.cos(rot), y +  scale *  Math.sin(rot));

	for (var i = 1; i <= numberOfSides;i += 1) {
		ctx.lineTo (x + scale * Math.cos(i * 2 * Math.PI / numberOfSides +rot), 
		y + scale * Math.sin(i * 2 * Math.PI / numberOfSides+rot));
	}

	ctx.strokeStyle = "#000000";
	ctx.lineWidth = 1;
	ctx.stroke();
}
</script>
</body>
</html>